import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:posfelix/data/models/models.dart';

/// Cart item for local state
class CartItem {
  final ProductModel product;
  final int quantity;
  final int unitPrice;
  final int unitHpp;

  CartItem({
    required this.product,
    required this.quantity,
    required this.unitPrice,
    required this.unitHpp,
  });

  int get subtotal => unitPrice * quantity;
  int get profit => (unitPrice - unitHpp) * quantity;

  CartItem copyWith({
    ProductModel? product,
    int? quantity,
    int? unitPrice,
    int? unitHpp,
  }) {
    return CartItem(
      product: product ?? this.product,
      quantity: quantity ?? this.quantity,
      unitPrice: unitPrice ?? this.unitPrice,
      unitHpp: unitHpp ?? this.unitHpp,
    );
  }

  /// Convert to TransactionItemModel for saving
  TransactionItemModel toTransactionItem(String transactionId) {
    return TransactionItemModel(
      id: '', // Will be generated by database
      transactionId: transactionId,
      productId: product.id,
      productName: product.name,
      productSku: product.sku,
      quantity: quantity,
      unitPrice: unitPrice,
      unitHpp: unitHpp,
      subtotal: subtotal,
    );
  }
}

/// Cart state
class CartState {
  final List<CartItem> items;
  final String tier;
  final String paymentMethod;
  final int discountAmount;
  final String? notes;

  const CartState({
    this.items = const [],
    this.tier = 'UMUM',
    this.paymentMethod = 'CASH',
    this.discountAmount = 0,
    this.notes,
  });

  CartState copyWith({
    List<CartItem>? items,
    String? tier,
    String? paymentMethod,
    int? discountAmount,
    String? notes,
  }) {
    return CartState(
      items: items ?? this.items,
      tier: tier ?? this.tier,
      paymentMethod: paymentMethod ?? this.paymentMethod,
      discountAmount: discountAmount ?? this.discountAmount,
      notes: notes ?? this.notes,
    );
  }

  int get subtotal => items.fold(0, (sum, item) => sum + item.subtotal);
  int get total => subtotal - discountAmount;
  int get totalHpp =>
      items.fold(0, (sum, item) => sum + (item.unitHpp * item.quantity));
  int get totalProfit => total - totalHpp;
  int get itemCount => items.fold(0, (sum, item) => sum + item.quantity);
  bool get isEmpty => items.isEmpty;
}

/// Cart notifier
class CartNotifier extends StateNotifier<CartState> {
  CartNotifier() : super(const CartState());

  void setTier(String tier) {
    // Update prices for all items based on new tier
    final updatedItems = state.items.map((item) {
      final newPrice = item.product.getPriceByTier(tier);
      return item.copyWith(unitPrice: newPrice);
    }).toList();

    state = state.copyWith(tier: tier, items: updatedItems);
  }

  void setPaymentMethod(String method) {
    state = state.copyWith(paymentMethod: method);
  }

  void setDiscount(int amount) {
    state = state.copyWith(discountAmount: amount);
  }

  void setNotes(String? notes) {
    state = state.copyWith(notes: notes);
  }

  void addItem(ProductModel product) {
    final existingIndex = state.items.indexWhere(
      (i) => i.product.id == product.id,
    );

    if (existingIndex >= 0) {
      // Increase quantity (but don't exceed stock)
      final existing = state.items[existingIndex];
      final newQuantity = existing.quantity + 1;
      final maxQuantity = existing.product.stock;

      if (newQuantity <= maxQuantity) {
        final updatedItems = [...state.items];
        updatedItems[existingIndex] = existing.copyWith(quantity: newQuantity);
        state = state.copyWith(items: updatedItems);
      }
    } else {
      // Add new item (only if stock available)
      if (product.stock > 0) {
        final price = product.getPriceByTier(state.tier);
        final newItem = CartItem(
          product: product,
          quantity: 1,
          unitPrice: price,
          unitHpp: product.hpp,
        );
        state = state.copyWith(items: [...state.items, newItem]);
      }
    }
  }

  void removeItem(String productId) {
    final updatedItems = state.items
        .where((i) => i.product.id != productId)
        .toList();
    state = state.copyWith(items: updatedItems);
  }

  void updateQuantity(String productId, int quantity) {
    if (quantity <= 0) {
      removeItem(productId);
      return;
    }

    final updatedItems = state.items.map((item) {
      if (item.product.id == productId) {
        // Validate quantity doesn't exceed available stock
        final maxQuantity = item.product.stock;
        final validQuantity = quantity > maxQuantity ? maxQuantity : quantity;
        return item.copyWith(quantity: validQuantity);
      }
      return item;
    }).toList();

    state = state.copyWith(items: updatedItems);
  }

  void incrementQuantity(String productId) {
    final item = state.items.firstWhere((i) => i.product.id == productId);
    // Check if we can increment (don't exceed stock)
    if (item.quantity < item.product.stock) {
      updateQuantity(productId, item.quantity + 1);
    }
  }

  void decrementQuantity(String productId) {
    final item = state.items.firstWhere((i) => i.product.id == productId);
    updateQuantity(productId, item.quantity - 1);
  }

  void clearCart() {
    state = const CartState();
  }

  /// Get items as TransactionItemModel list
  List<TransactionItemModel> getTransactionItems(String transactionId) {
    return state.items
        .map((item) => item.toTransactionItem(transactionId))
        .toList();
  }
}

/// Cart provider
final cartProvider = StateNotifierProvider<CartNotifier, CartState>((ref) {
  return CartNotifier();
});
